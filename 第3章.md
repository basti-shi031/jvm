# 第3章

## 3.1 概述

三个问题：

* 哪些内存需要回收？
* 何时回收？
* 如何回收？

## 3.2 对象已死吗？

GC在对队进行回收前，第一件事情就是要确定这些对象还有哪些存活。

### 3.2.1引用计数法

给对象添加一个引用计数器，每当有一个地方引用时，计数器+1；引用失效时-1。为0时，该对象就不可能再被使用。

* 实现简单，判定效率高。
* 无法解决循环引用的问题。

```java
public class ReferenceCountingGC{
    public Object instance = null;
    
    public void testGC(){
        ReferenceCountingGC objA = new ReferenceCountingGC();
        ReferenceCountingGC objB = new ReferenceCountingGC();
        
        objA.instance = objB;
        objB.instance = objA;
        
        objA = null;
        objB = null;
    }
}
```

objA 和 objB 两个对象相互引用，在置为null以后，两个对象都无法被访问，但因为各自引用着对方，导致计数不为0，无法回收。

### 3.2.2可达性分析算法

主流实现。

基本思路：通过一系列成为“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为**引用链**，当一个对象到GC Roots 没有任何引用链相连（不可达），证明该对象不可用。

可作为GC Roots的对象：

* 虚拟机栈中引用的对象。
* 方法区中静态属性引用的对象。
* 方法区中常量引用的对象。
* 本地方法中JNI引用的对象。

### 3.2.3再谈引用

* 强引用：类似于```obj =  new Obj();```这类引用。只要强引用存在，就不会被回收。
* 软引用：描述**有用**但**非必需**的对象。在系统将要发生OOM之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还是没有足够的内存，才会抛出OOM。`SoftReference类`实现软引用。
* 弱引用：**非必需**，强度比**软引用**更低。只要发生GC，一定会被回收。`WeakReference类`实现弱引用。
* 虚引用：幽灵引用或幻影引用。为一个对象设置虚引用关联，唯一目的就是**在这个对象被回收时收到一个系统通知**。`PhantomReference类`实现。

### 3.2.4生存还是死亡

宣告一个对象死亡，至少经历两次标记过程：判定一个对象不可达后，将被**第一次标记并且进行一次筛选**，筛选条件是此对象收**有必要执行`finalize()`方法**。当对象没有覆盖`finalize()`方法，或者`finalize`方法已经被虚拟机调用过，虚拟机将这两种情况视为“没有必要执行”。

如果有必要执行`finalize`方法，那么这个对象将会放置在一个叫`F-Queue`的队列中，并在稍后由一个虚拟机自动建立的、低优先级的`Finalizer`线程去执行它（触发这个方法）。